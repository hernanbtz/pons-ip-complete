/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package com.mycompany.pons;

import java.awt.Color;
import java.awt.Component;
import java.awt.Desktop;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.*;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.WorkbookFactory;

/**
 *
 * @author sergi
 */
public class ImpExcelBC extends javax.swing.JFrame {

    private int vista = 0;
    private int indiceFila = 0;
    private String columnaDatos = "";
    private ArrayList<String> prueba;
    private HashMap<String, String> valores;
    private boolean isImport = false;

    /**
     * Creates new form ImpExcelBC
     */
    public ImpExcelBC() {
        initComponents();
        iniciarVista();
        setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        jPanel1 = new javax.swing.JPanel();
        btn_importBC = new javax.swing.JButton();
        btn_importApi = new javax.swing.JButton();
        btn_exportar = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        btn_rellenar = new javax.swing.JButton();
        scroll_BC = new javax.swing.JScrollPane();
        tb_importBC = new javax.swing.JTable();
        scroll_API = new javax.swing.JScrollPane();
        tb_importAPI = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        cb_bc = new javax.swing.JComboBox<>();
        cb_api = new javax.swing.JComboBox<>();
        txt_nombretabla = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        btn_BorrarFilas = new javax.swing.JButton();
        btn_BorrarColumna = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        scroll_SF = new javax.swing.JScrollPane();
        tb_importSF = new javax.swing.JTable();
        btn_importSF = new javax.swing.JButton();
        rbAPI = new javax.swing.JRadioButton();
        rbBC = new javax.swing.JRadioButton();
        jLabel12 = new javax.swing.JLabel();
        cb_sf = new javax.swing.JComboBox<>();
        btDeshacer = new javax.swing.JButton();
        jLabel14 = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();
        txt_tablapreview = new javax.swing.JLabel();
        btn_siguientemodificado = new javax.swing.JButton();
        btn_ocultar = new javax.swing.JButton();
        btn_mostrar = new javax.swing.JButton();
        txt_dtTotal = new javax.swing.JLabel();
        btn_siguientevacio = new javax.swing.JButton();
        txt_buscador = new javax.swing.JTextField();
        btn_buscar = new javax.swing.JButton();
        btn_rellenarDC = new javax.swing.JButton();
        descargarPDF = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setMinimumSize(new java.awt.Dimension(1280, 720));
        setSize(new java.awt.Dimension(1280, 720));
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jPanel1.setBackground(new java.awt.Color(220, 220, 255));
        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 3));
        jPanel1.setMinimumSize(new java.awt.Dimension(1280, 720));
        jPanel1.setPreferredSize(new java.awt.Dimension(1280, 720));
        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        btn_importBC.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_importBC.setText("Importar Excel de BC");
        btn_importBC.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_importBCActionPerformed(evt);
            }
        });
        jPanel1.add(btn_importBC, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 680, -1, -1));

        btn_importApi.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_importApi.setText("Importar Excel de Apiges");
        btn_importApi.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_importApiActionPerformed(evt);
            }
        });
        jPanel1.add(btn_importApi, new org.netbeans.lib.awtextra.AbsoluteConstraints(350, 680, -1, -1));

        btn_exportar.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_exportar.setText("Exportar");
        btn_exportar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_exportarActionPerformed(evt);
            }
        });
        jPanel1.add(btn_exportar, new org.netbeans.lib.awtextra.AbsoluteConstraints(1170, 680, 100, -1));

        jButton1.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        jButton1.setText("CAMBIAR VISTA A EXCEL APIGES");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        jPanel1.add(jButton1, new org.netbeans.lib.awtextra.AbsoluteConstraints(530, 140, -1, -1));

        btn_rellenar.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_rellenar.setText("RELLENAR");
        btn_rellenar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_rellenarActionPerformed(evt);
            }
        });
        jPanel1.add(btn_rellenar, new org.netbeans.lib.awtextra.AbsoluteConstraints(180, 150, 170, -1));

        scroll_BC.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        scroll_BC.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        scroll_BC.setMaximumSize(new java.awt.Dimension(1270, 570));
        scroll_BC.setMinimumSize(new java.awt.Dimension(1270, 570));
        scroll_BC.setName(""); // NOI18N
        scroll_BC.setPreferredSize(new java.awt.Dimension(1270, 570));

        tb_importBC.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "", "", "", ""
            }
        ));
        tb_importBC.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                tb_importBCMouseClicked(evt);
            }
        });
        scroll_BC.setViewportView(tb_importBC);

        jPanel1.add(scroll_BC, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 210, 1260, 420));

        scroll_API.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        scroll_API.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        scroll_API.setMaximumSize(new java.awt.Dimension(1270, 570));
        scroll_API.setMinimumSize(new java.awt.Dimension(1270, 570));
        scroll_API.setName(""); // NOI18N
        scroll_API.setPreferredSize(new java.awt.Dimension(1270, 570));

        tb_importAPI.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "", "", "", ""
            }
        ));
        tb_importAPI.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                tb_importAPIMouseClicked(evt);
            }
        });
        scroll_API.setViewportView(tb_importAPI);

        jPanel1.add(scroll_API, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 210, 1260, 420));

        jLabel1.setText("Columna de referencia en BC");
        jPanel1.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(1000, 100, -1, -1));

        jLabel2.setText("Columna de referencia en Apiges");
        jPanel1.add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(1000, 150, -1, -1));

        jPanel1.add(cb_bc, new org.netbeans.lib.awtextra.AbsoluteConstraints(1000, 120, 270, -1));

        jPanel1.add(cb_api, new org.netbeans.lib.awtextra.AbsoluteConstraints(1000, 170, 270, -1));

        txt_nombretabla.setFont(new java.awt.Font("Calibri", 1, 24)); // NOI18N
        txt_nombretabla.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        txt_nombretabla.setText("NOMBRE DE LA TABLA");
        jPanel1.add(txt_nombretabla, new org.netbeans.lib.awtextra.AbsoluteConstraints(470, 170, 330, 40));

        jLabel6.setFont(new java.awt.Font("Calibri", 1, 36)); // NOI18N
        jLabel6.setText("COMPLETACIÓN DATOS PONS IP");
        jPanel1.add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(390, 0, 540, 70));

        btn_BorrarFilas.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_BorrarFilas.setText("Borrar filas");
        btn_BorrarFilas.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_BorrarFilasActionPerformed(evt);
            }
        });
        jPanel1.add(btn_BorrarFilas, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 70, 130, -1));

        btn_BorrarColumna.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_BorrarColumna.setText("Borrar columna");
        btn_BorrarColumna.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_BorrarColumnaActionPerformed(evt);
            }
        });
        jPanel1.add(btn_BorrarColumna, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 100, 130, -1));

        jLabel5.setFont(new java.awt.Font("Calibri", 1, 18)); // NOI18N
        jLabel5.setText("IMPORTAR EXCEL");
        jPanel1.add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 650, -1, -1));

        jLabel10.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/infoIcon.png"))); // NOI18N
        jLabel10.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel10MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel10, new org.netbeans.lib.awtextra.AbsoluteConstraints(150, 650, 20, -1));

        jLabel9.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/infoIcon.png"))); // NOI18N
        jLabel9.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel9MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel9, new org.netbeans.lib.awtextra.AbsoluteConstraints(90, 50, 20, -1));

        jLabel7.setFont(new java.awt.Font("Calibri", 1, 18)); // NOI18N
        jLabel7.setText("FORMATO");
        jPanel1.add(jLabel7, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 50, -1, -1));

        jLabel8.setFont(new java.awt.Font("Calibri", 1, 18)); // NOI18N
        jLabel8.setText("EXPORTAR EXCEL");
        jPanel1.add(jLabel8, new org.netbeans.lib.awtextra.AbsoluteConstraints(1140, 650, -1, -1));

        jLabel11.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/infoIcon.png"))); // NOI18N
        jLabel11.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel11MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel11, new org.netbeans.lib.awtextra.AbsoluteConstraints(1120, 650, 20, -1));

        scroll_SF.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        scroll_SF.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        scroll_SF.setMaximumSize(new java.awt.Dimension(1270, 570));
        scroll_SF.setMinimumSize(new java.awt.Dimension(1270, 570));
        scroll_SF.setName(""); // NOI18N
        scroll_SF.setPreferredSize(new java.awt.Dimension(1270, 570));

        tb_importSF.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "", "", "", ""
            }
        ));
        tb_importSF.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                tb_importSFMouseClicked(evt);
            }
        });
        scroll_SF.setViewportView(tb_importSF);

        jPanel1.add(scroll_SF, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 210, 1260, 420));

        btn_importSF.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_importSF.setText("Importar Excel de SF");
        btn_importSF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_importSFActionPerformed(evt);
            }
        });
        jPanel1.add(btn_importSF, new org.netbeans.lib.awtextra.AbsoluteConstraints(180, 680, -1, -1));

        rbAPI.setBackground(new java.awt.Color(220, 220, 255));
        buttonGroup1.add(rbAPI);
        rbAPI.setText("APIGES");
        rbAPI.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbAPIActionPerformed(evt);
            }
        });
        jPanel1.add(rbAPI, new org.netbeans.lib.awtextra.AbsoluteConstraints(820, 90, -1, -1));

        rbBC.setBackground(new java.awt.Color(220, 220, 255));
        buttonGroup1.add(rbBC);
        rbBC.setText("Business Central");
        rbBC.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbBCActionPerformed(evt);
            }
        });
        jPanel1.add(rbBC, new org.netbeans.lib.awtextra.AbsoluteConstraints(820, 70, -1, -1));

        jLabel12.setText("Columna de referencia en SF");
        jPanel1.add(jLabel12, new org.netbeans.lib.awtextra.AbsoluteConstraints(1000, 50, -1, -1));

        cb_sf.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cb_sfActionPerformed(evt);
            }
        });
        jPanel1.add(cb_sf, new org.netbeans.lib.awtextra.AbsoluteConstraints(1000, 70, 270, -1));

        btDeshacer.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btDeshacer.setText("Deshacer");
        btDeshacer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btDeshacerActionPerformed(evt);
            }
        });
        jPanel1.add(btDeshacer, new org.netbeans.lib.awtextra.AbsoluteConstraints(200, 120, 130, -1));

        jLabel14.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/infoIcon.png"))); // NOI18N
        jLabel14.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel14MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel14, new org.netbeans.lib.awtextra.AbsoluteConstraints(1000, 30, 20, -1));

        jLabel15.setFont(new java.awt.Font("Calibri", 1, 18)); // NOI18N
        jLabel15.setText("DEPURACIÓN");
        jPanel1.add(jLabel15, new org.netbeans.lib.awtextra.AbsoluteConstraints(1020, 30, -1, -1));

        txt_tablapreview.setFont(new java.awt.Font("Calibri", 1, 36)); // NOI18N
        txt_tablapreview.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        txt_tablapreview.setText("(AQUÍ SE MOSTRARÁ LA TABLA)");
        jPanel1.add(txt_tablapreview, new org.netbeans.lib.awtextra.AbsoluteConstraints(220, 320, 860, 180));

        btn_siguientemodificado.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_siguientemodificado.setText("SIGUIENTE REGISTRO MODIFICADO");
        btn_siguientemodificado.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_siguientemodificadoActionPerformed(evt);
            }
        });
        jPanel1.add(btn_siguientemodificado, new org.netbeans.lib.awtextra.AbsoluteConstraints(620, 640, 250, -1));

        btn_ocultar.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_ocultar.setText("OCULTAR ");
        btn_ocultar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_ocultarActionPerformed(evt);
            }
        });
        jPanel1.add(btn_ocultar, new org.netbeans.lib.awtextra.AbsoluteConstraints(820, 170, 170, -1));

        btn_mostrar.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_mostrar.setText("MOSTRAR");
        btn_mostrar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_mostrarActionPerformed(evt);
            }
        });
        jPanel1.add(btn_mostrar, new org.netbeans.lib.awtextra.AbsoluteConstraints(820, 140, 170, -1));
        jPanel1.add(txt_dtTotal, new org.netbeans.lib.awtextra.AbsoluteConstraints(190, 650, 250, 20));

        btn_siguientevacio.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_siguientevacio.setText("SIGUIENTE REGISTRO VACIO");
        btn_siguientevacio.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_siguientevacioActionPerformed(evt);
            }
        });
        jPanel1.add(btn_siguientevacio, new org.netbeans.lib.awtextra.AbsoluteConstraints(880, 640, 220, -1));
        jPanel1.add(txt_buscador, new org.netbeans.lib.awtextra.AbsoluteConstraints(530, 100, 210, 30));

        btn_buscar.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_buscar.setText("BUSCAR");
        btn_buscar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_buscarActionPerformed(evt);
            }
        });
        jPanel1.add(btn_buscar, new org.netbeans.lib.awtextra.AbsoluteConstraints(590, 70, -1, -1));

        btn_rellenarDC.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        btn_rellenarDC.setText("SUSTITUIR DOMICILIOS CONTACTOS");
        btn_rellenarDC.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_rellenarDCActionPerformed(evt);
            }
        });
        jPanel1.add(btn_rellenarDC, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 180, 310, -1));

        descargarPDF.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        descargarPDF.setText("DESCARGAR PDF INSTRUCTIVO");
        descargarPDF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                descargarPDFActionPerformed(evt);
            }
        });
        jPanel1.add(descargarPDF, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 10, 310, -1));

        getContentPane().add(jPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, -1, -1));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked

    }//GEN-LAST:event_formMouseClicked

    private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized

    }//GEN-LAST:event_formComponentResized

    private void btn_rellenarDCActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_rellenarDCActionPerformed
        rellenarDC();
    }//GEN-LAST:event_btn_rellenarDCActionPerformed
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btn_buscar". Verifica qué tabla (tb_importAPI, tb_importBC o
     * tb_importSF) está visible en ese momento y llama al método "buscador" con
     * los parámetros correspondientes: - El índice de la columna seleccionada
     * en la tabla. - El número de fila seleccionada más uno (para ajustar el
     * índice base 0 de Java al índice base 1 de las filas visibles en la
     * tabla). - La tabla correspondiente.
     */
    private void btn_buscarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_buscarActionPerformed
        if (tb_importAPI.isVisible()) {
            buscador(tb_importAPI.getSelectedColumn(), tb_importAPI.getSelectedRow() + 1, tb_importAPI);
        } else if (tb_importBC.isVisible()) {
            buscador(tb_importBC.getSelectedColumn(), tb_importBC.getSelectedRow() + 1, tb_importBC);
        } else if (tb_importSF.isVisible()) {
            buscador(tb_importSF.getSelectedColumn(), tb_importSF.getSelectedRow() + 1, tb_importSF);
        }
    }//GEN-LAST:event_btn_buscarActionPerformed

    private void btn_siguientevacioActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_siguientevacioActionPerformed
        siguienteVacia(tb_importSF.getSelectedRow() + 1);
    }//GEN-LAST:event_btn_siguientevacioActionPerformed
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btn_mostrar". Verifica qué tabla (tb_importSF, tb_importAPI o
     * tb_importBC) está visible en ese momento y llama al método
     * "mostrarCeldas" con la tabla correspondiente. El método "mostrarCeldas"
     * se encarga de mostrar todas las celdas de la tabla en su totalidad.
     */
    private void btn_mostrarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_mostrarActionPerformed
        if (tb_importSF.isVisible()) {
            mostrarCeldas(tb_importSF);
        } else if (tb_importAPI.isVisible()) {
            mostrarCeldas(tb_importAPI);
        } else if (tb_importBC.isVisible()) {
            mostrarCeldas(tb_importBC);
        }
    }//GEN-LAST:event_btn_mostrarActionPerformed
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btn_ocultar". Verifica qué tabla (tb_importSF, tb_importAPI o
     * tb_importBC) está visible en ese momento y llama al método
     * "ocultarCeldas" con la tabla correspondiente. El método "ocultarCeldas"
     * se encarga de ocultar las celdas seleccionadas de la tabla.
     */
    private void btn_ocultarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_ocultarActionPerformed
        if (tb_importSF.isVisible()) {
            ocultarCeldas(tb_importSF);
        } else if (tb_importAPI.isVisible()) {
            ocultarCeldas(tb_importAPI);
        } else if (tb_importBC.isVisible()) {
            ocultarCeldas(tb_importBC);
        }
    }//GEN-LAST:event_btn_ocultarActionPerformed

    private void btn_siguientemodificadoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_siguientemodificadoActionPerformed
        siguienteModificada(tb_importSF.getSelectedRow() + 1);
    }//GEN-LAST:event_btn_siguientemodificadoActionPerformed

    private void jLabel14MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel14MouseClicked
        JOptionPane.showMessageDialog(rootPane, "Elige las columnas que se van a comparar entre las diferentes tablas.");
    }//GEN-LAST:event_jLabel14MouseClicked
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btDeshacer". Deshace la acción realizada anteriormente en la tabla
     * tb_importSF. Habilita o deshabilita el botón "btDeshacer" según sea
     * necesario.
     */
    private void btDeshacerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btDeshacerActionPerformed
        deshacer(tb_importSF);
        btDeshacer.setEnabled(false);
    }//GEN-LAST:event_btDeshacerActionPerformed

    private void cb_sfActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cb_sfActionPerformed
        if (cb_sf.getSelectedItem() != null) {
            btn_rellenar.setEnabled(true);
        }
    }//GEN-LAST:event_cb_sfActionPerformed

    private void rbBCActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbBCActionPerformed
        cb_sf.setEnabled(true);
        cb_bc.setEnabled(true);
        cb_api.setEnabled(false);
    }//GEN-LAST:event_rbBCActionPerformed

    private void rbAPIActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbAPIActionPerformed
        cb_api.setEnabled(true);
        cb_sf.setEnabled(true);
        cb_bc.setEnabled(false);
    }//GEN-LAST:event_rbAPIActionPerformed
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btn_importSF". Intenta importar los datos desde un archivo de Excel a la
     * tabla "tb_importSF". Si la importación es exitosa, se habilitan los
     * controles btn_exportar, btn_BorrarFilas y btn_BorrarColumna. Además, se
     * llama al método cambiarVista(1) para cambiar la vista a la tabla
     * "tb_importBC".
     */
    private void btn_importSFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_importSFActionPerformed
        if (importarExcel(tb_importSF)) {
            btn_exportar.setEnabled(true);
            btn_BorrarFilas.setEnabled(true);
            btn_BorrarColumna.setEnabled(true);
            //almacenarTabla();
            cambiarVista(1);
        }
    }//GEN-LAST:event_btn_importSFActionPerformed

    private void tb_importSFMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tb_importSFMouseClicked
        txt_dtTotal.setText(datosTotales(tb_importSF));
    }//GEN-LAST:event_tb_importSFMouseClicked

    private void jLabel11MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel11MouseClicked
        JOptionPane.showMessageDialog(rootPane, "Exporta la tabla de la vista a una hoja de Excel. Asegúrate de que no hay columnas vacías y de que no hay ninguna fila fuera de formato.\nRecuerda que solo se exportará la tabla de SF");
    }//GEN-LAST:event_jLabel11MouseClicked

    private void jLabel9MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel9MouseClicked
        JOptionPane.showMessageDialog(rootPane, "Formatea la tabla.\nEl botón 'Borrar filas' te pide el número de filas que quieres borrar AL FINAL de la tabla.\nEl botón borrar columna te pide el NÚMERO DE COLUMNA que quieres borrar.");
    }//GEN-LAST:event_jLabel9MouseClicked

    private void jLabel10MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel10MouseClicked
        JOptionPane.showMessageDialog(rootPane, "Elige el archivo excel que quieres subir.\nCada botón corresponde a una plataforma diferente.");
    }//GEN-LAST:event_jLabel10MouseClicked
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btn_BorrarColumna". Dependiendo del valor de la variable "vista", se
     * ejecuta el método "borrarColumnas" en la tabla correspondiente. Los casos
     * posibles de "vista" son: - 0: se llama a "borrarColumnas" en la tabla
     * "tb_importAPI". - 1: se llama a "borrarColumnas" en la tabla
     * "tb_importBC". - 2: se llama a "borrarColumnas" en la tabla
     * "tb_importSF". No se realiza ninguna acción por defecto.
     */
    private void btn_BorrarColumnaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_BorrarColumnaActionPerformed
        switch (vista) {
            case 0:
                borrarColumnas(tb_importAPI);
                break;
            case 1:
                borrarColumnas(tb_importBC);
                break;
            case 2:
                borrarColumnas(tb_importSF);
            default:
                break;
        }
    }//GEN-LAST:event_btn_BorrarColumnaActionPerformed
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btn_BorrarFilas". Dependiendo del valor de la variable "vista", se
     * ejecuta el método "borrarFilas" en la tabla correspondiente. Los casos
     * posibles de "vista" son: - 0: se llama a "borrarFilas" en la tabla
     * "tb_importAPI". - 1: se llama a "borrarFilas" en la tabla "tb_importBC".
     * - 2: se llama a "borrarFilas" en la tabla "tb_importSF". No se realiza
     * ninguna acción por defecto.
     */
    private void btn_BorrarFilasActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_BorrarFilasActionPerformed
        switch (vista) {
            case 0:
                borrarFilas(tb_importAPI);
                break;
            case 1:
                borrarFilas(tb_importBC);
                break;
            case 2:
                borrarFilas(tb_importSF);
            default:
                break;
        }
    }//GEN-LAST:event_btn_BorrarFilasActionPerformed

    private void tb_importAPIMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tb_importAPIMouseClicked
        txt_dtTotal.setText(datosTotales(tb_importAPI));
    }//GEN-LAST:event_tb_importAPIMouseClicked

    private void tb_importBCMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tb_importBCMouseClicked
        txt_dtTotal.setText(datosTotales(tb_importBC));
    }//GEN-LAST:event_tb_importBCMouseClicked
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btn_rellenar". Verifica si no se ha seleccionado ninguna columna en la
     * tabla "tb_importSF" o si la columna seleccionada está fuera de rango. Si
     * se cumple alguna de estas condiciones, se muestra un mensaje de
     * advertencia. De lo contrario, se llama al método "rellenar" para realizar
     * la acción correspondiente.
     */
    private void btn_rellenarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_rellenarActionPerformed
        if (tb_importSF.getSelectedColumn() < 0 || tb_importSF.getSelectedColumn() > tb_importSF.getColumnCount()) {
            JOptionPane.showMessageDialog(this, "Selecciona una columna pinchando en cualquiera de sus celdas");
        } else {
            rellenar();
        }
    }//GEN-LAST:event_btn_rellenarActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        cambiarVista(vista);
    }//GEN-LAST:event_jButton1ActionPerformed
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btn_exportar". Intenta exportar los datos de la tabla "tb_importSF" a un
     * archivo de Excel. Si se produce alguna excepción de tipo IOException
     * durante el proceso de exportación, se registra el error en el registro de
     * errores.
     */
    private void btn_exportarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_exportarActionPerformed
        try {
            exportarExcel(tb_importSF);

        } catch (IOException ex) {
            Logger.getLogger(ImpExcelBC.class
                    .getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_btn_exportarActionPerformed
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btn_importApi". Intenta importar los datos desde un archivo de Excel a
     * la tabla "tb_importAPI". Si la importación es exitosa, se habilitan los
     * controles rbAPI, btn_BorrarFilas y btn_BorrarColumna. Además, se llama al
     * método cambiarVista(2) para cambiar la vista a la tabla "tb_importSF".
     */
    private void btn_importApiActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_importApiActionPerformed
        if (importarExcel(tb_importAPI)) {
            rbAPI.setEnabled(true);
            btn_BorrarFilas.setEnabled(true);
            btn_BorrarColumna.setEnabled(true);
            cambiarVista(2);
        }
    }//GEN-LAST:event_btn_importApiActionPerformed
    /**
     * Este método se ejecuta cuando se activa el evento de acción del botón
     * "btn_importBC". Intenta importar los datos desde un archivo de Excel a la
     * tabla "tb_importBC". Si la importación es exitosa, se habilitan los
     * controles rbBC, btn_BorrarFilas y btn_BorrarColumna. Además, se llama al
     * método cambiarVista(0) para cambiar la vista a la tabla "tb_importAPI".
     */
    private void btn_importBCActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_importBCActionPerformed
        if (importarExcel(tb_importBC)) {
            rbBC.setEnabled(true);
            btn_BorrarFilas.setEnabled(true);
            btn_BorrarColumna.setEnabled(true);
            cambiarVista(0);
        }
    }//GEN-LAST:event_btn_importBCActionPerformed

    private void descargarPDFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_descargarPDFActionPerformed
        descargarPDF();
    }//GEN-LAST:event_descargarPDFActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ImpExcelBC.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ImpExcelBC.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ImpExcelBC.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ImpExcelBC.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ImpExcelBC().setVisible(true);
            }
        });
    }

    /**
     * Este método se utiliza para buscar un dato específico en una tabla.
     * Recibe como parámetros la columna y fila iniciales donde se iniciará la
     * búsqueda, así como la tabla (JTable) en la que se realizará la búsqueda.
     * El método obtiene el dato a buscar desde el campo de texto
     * "txt_buscador". Luego, recorre las celdas de la tabla a partir de la
     * columna y fila iniciales. Si encuentra una celda con el dato buscado,
     * selecciona la fila y columna correspondiente, y realiza un desplazamiento
     * de la vista de la tabla para que la celda buscada sea visible. Si no se
     * encuentra el dato buscado, se muestra un mensaje de advertencia.
     */
    private void buscador(int columna, int fila, JTable t) {
        try {
            String datoAbuscar = String.valueOf(txt_buscador.getText());
            for (int i = columna; i < t.getColumnCount(); i++) {
                for (int j = fila; j < t.getRowCount(); j++) {
                    String dato = String.valueOf(t.getValueAt(j, i));
                    if (dato.equalsIgnoreCase(datoAbuscar)) {
                        t.setRowSelectionInterval(j, j);
                        JViewport viewport = (JViewport) t.getParent();
                        Rectangle rect = t.getCellRect(j, i, true);
                        Point pt = viewport.getViewPosition();
                        rect.setLocation(rect.x - pt.x, rect.y - pt.y);
                        viewport.scrollRectToVisible(rect);
                        t.setColumnSelectionInterval(i, i);
                        return;
                    }
                }
                fila = 0;
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "No se han encontrado resultados");
        }

    }

    /**
     * Este método se utiliza para obtener el número de datos totales en una
     * tabla. Recibe como parámetro la tabla (JTable) para la cual se desea
     * obtener el número de datos totales. El método recorre las filas de la
     * tabla y verifica si la altura de la fila es igual a 16. Si la altura es
     * igual a 16, se considera que la fila contiene datos y se incrementa el
     * contador. Al final, se retorna una cadena de texto que indica el número
     * de datos totales.
     */
    private String datosTotales(JTable t) {
        int n = 0;
        String sn = "Datos Totales: ";
        for (int i = 0; i < t.getRowCount(); i++) {
            if (t.getRowHeight(i) == 16) {
                n++;
            }
        }
        sn += n;
        return sn;
    }

    /**
     * Este método se utiliza para mostrar las celdas ocultas en una columna
     * específica de una tabla. Recibe como parámetro la tabla (JTable) en la
     * que se van a mostrar las celdas. El método recorre todas las filas de la
     * tabla y verifica si el valor de la celda en la columna seleccionada es
     * una cadena vacía. Si es una cadena vacía, se ajusta la altura de la fila
     * a 16 píxeles para mostrar la celda.
     */
    private void mostrarCeldas(JTable t) {
        for (int i = 0; i < t.getRowCount(); i++) {
            String dato = String.valueOf(t.getValueAt(i, t.getSelectedColumn()));
            if (dato.equals("")) {
                t.setRowHeight(i, 16);
            }
        }
    }

    /**
     * Este método se utiliza para ocultar las celdas vacías en una columna
     * específica de una tabla. Recibe como parámetro la tabla (JTable) en la
     * que se van a ocultar las celdas. El método recorre todas las filas de la
     * tabla y verifica si el valor de la celda en la columna seleccionada es
     * una cadena vacía o nula. Si es así y la altura de la fila es mayor a 1
     * (es decir, la celda no está previamente oculta), se ajusta la altura de
     * la fila a 1 para ocultar la celda. Además, el método muestra un mensaje
     * de diálogo indicando la cantidad de celdas vacías ocultas.
     */
    private void ocultarCeldas(JTable t) {
        int celdas_vacias = 0;
        for (int i = 0; i < t.getRowCount(); i++) {
            String dato = String.valueOf(t.getValueAt(i, t.getSelectedColumn()));
            if (dato == null || dato.equals("") && t.getRowHeight(i) > 1) {
                t.setRowHeight(i, 1);
                celdas_vacias++;
            }
        }
        JOptionPane.showMessageDialog(this, "Hay " + celdas_vacias + " celdas vacías");
    }

    /**
     * Este método se utiliza para buscar la siguiente celda modificada en una
     * tabla, a partir de una posición de fila específica. Recibe como parámetro
     * el número de fila a partir del cual se realizará la búsqueda. El método
     * recorre las filas de la tabla a partir de la posición especificada. Para
     * cada fila, compara el valor de la celda en la columna seleccionada con el
     * valor almacenado en la lista de prueba (prueba). Si los valores son
     * diferentes, se selecciona la fila en la tabla, se obtiene la vista
     * principal (viewport) y se calcula el rectángulo de la celda. Luego se
     * ajusta la posición de la vista para que la celda sea visible en la
     * ventana. Finalmente, se interrumpe el bucle. Si ocurre alguna excepción
     * durante el proceso, se muestra un mensaje de diálogo indicando que se
     * debe seleccionar la primera celda para comenzar la búsqueda.
     */
    private void siguienteModificada(int n) {
        try {
            for (int i = n; i < tb_importSF.getRowCount(); i++) {
                String dato = String.valueOf(tb_importSF.getValueAt(i, tb_importSF.getSelectedColumn()));
                if (!prueba.get(i).equals(dato)) {
                    tb_importSF.setRowSelectionInterval(i, i);
                    JViewport viewport = (JViewport) tb_importSF.getParent();
                    Rectangle rect = tb_importSF.getCellRect(i, tb_importSF.getSelectedColumn(), true);
                    Point pt = viewport.getViewPosition();
                    rect.setLocation(rect.x - pt.x, rect.y - pt.y);
                    viewport.scrollRectToVisible(rect);
                    break;
                }
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Selecciona la primera celda para comenzar a buscar");
        }
    }

    /**
     * Este método se utiliza para buscar la siguiente celda vacía en una tabla,
     * a partir de una posición de fila específica. Recibe como parámetro el
     * número de fila a partir del cual se realizará la búsqueda. El método
     * recorre las filas de la tabla a partir de la posición especificada. Para
     * cada fila, compara el valor de la celda en la columna seleccionada con
     * una cadena vacía. Si el valor es una cadena vacía, se selecciona la fila
     * en la tabla, se obtiene la vista principal (viewport) y se calcula el
     * rectángulo de la celda. Luego se ajusta la posición de la vista para que
     * la celda sea visible en la ventana. Finalmente, se interrumpe el bucle.
     * Si ocurre alguna excepción durante el proceso, se muestra un mensaje de
     * diálogo indicando que se debe seleccionar la primera celda para comenzar
     * la búsqueda.
     */
    private void siguienteVacia(int n) {
        try {
            for (int i = n; i < tb_importSF.getRowCount(); i++) {
                String dato = String.valueOf(tb_importSF.getValueAt(i, tb_importSF.getSelectedColumn()));
                if (dato.equals("")) {
                    tb_importSF.setRowSelectionInterval(i, i);
                    JViewport viewport = (JViewport) tb_importSF.getParent();
                    Rectangle rect = tb_importSF.getCellRect(i, tb_importSF.getSelectedColumn(), true);
                    Point pt = viewport.getViewPosition();
                    rect.setLocation(rect.x - pt.x, rect.y - pt.y);
                    viewport.scrollRectToVisible(rect);
                    break;
                }
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Selecciona la primera celda para comenzar a buscar");
        }
    }

    /**
     * Este método se utiliza para mostrar un diálogo con un JComboBox que
     * contiene las opciones de columnas de una tabla. Recibe como parámetro la
     * tabla (JTable) de la cual se obtienen las opciones de columna. El método
     * crea un JComboBox y una lista (comboSort) para almacenar las opciones de
     * columna. Se recorre la lista de columnas de la tabla y se agrega a
     * comboSort el encabezado de cada columna que no esté vacío. Se ordena la
     * lista comboSort. Se agregan los elementos de comboSort al JComboBox. Se
     * muestra un diálogo con el JComboBox y se espera a que el usuario
     * seleccione una opción y cierre el diálogo. Si el diálogo se cierra con la
     * opción "Aceptar" (0), se obtiene el valor seleccionado en el JComboBox y
     * se devuelve como resultado. Si el diálogo se cierra con otra opción, se
     * devuelve una cadena vacía.
     */
    private String sacarOpcion(JTable t) {
        JComboBox combo = new JComboBox();
        ArrayList<String> comboSort = new ArrayList<>();
        for (int i = 0; i < t.getColumnCount(); i++) {
            if (!t.getColumnModel().getColumn(i).getHeaderValue().equals("")) {
                comboSort.add(String.valueOf(t.getColumnModel().getColumn(i).getHeaderValue()));
            }
        }
        Collections.sort(comboSort);
        for (int i = 0; i < comboSort.size(); i++) {
            combo.addItem(comboSort.get(i));
        }
        int close = JOptionPane.showConfirmDialog(null, combo, "Tabla con los datos para rellenar", JOptionPane.YES_OPTION);
        String dato = "";
        if (close == 0) {
            dato = String.valueOf(combo.getSelectedItem());
        }
        return dato;
    }

    /**
     * Este método se utiliza para obtener el índice de la columna que contiene
     * datos en una tabla. Recibe como parámetro la tabla (JTable) en la que se
     * va a buscar la columna con datos. El método llama a la función
     * sacarOpcion para obtener el nombre de la columna seleccionada como
     * opción. Si el nombre de la columna no es una cadena vacía, se recorre la
     * lista de columnas de la tabla y se busca la columna que tenga como
     * encabezado el nombre de la opción. Si se encuentra la columna, se guarda
     * el índice de la columna. Si no se encuentra la columna, se asigna -1 como
     * índice de columna. Al finalizar, se retorna el índice de la columna con
     * datos o -1 si no se encuentra.
     */
    private int sacarColumnaConDatos(JTable t) {
        columnaDatos = sacarOpcion(t);
        int indiceColumna = 0;
        if (!columnaDatos.equals("")) {
            if (t.isVisible()) {
                for (int i = 0; i < t.getColumnCount(); i++) {
                    if (t.getColumnModel().getColumn(i).getHeaderValue().equals(columnaDatos)) {
                        indiceColumna = i;
                    }
                }
            }
        } else {
            indiceColumna = -1;
        }

        return indiceColumna;
    }

    /**
     * Este método se utiliza para obtener el índice de la columna de referencia
     * en una tabla, según el valor seleccionado en un JComboBox. Recibe como
     * parámetros la tabla (JTable) en la que se va a buscar la columna de
     * referencia y el JComboBox que contiene los valores de referencia. El
     * método recorre la lista de columnas de la tabla y compara el encabezado
     * de cada columna con el valor seleccionado en el JComboBox. Si encuentra
     * una coincidencia, guarda el índice de la columna. Al finalizar, retorna
     * el índice de la columna de referencia.
     */
    private int sacarColumnaRef(JTable t, JComboBox cb) {
        int indiceColumna = 0;
        if (t.isVisible()) {
            for (int i = 0; i < t.getColumnCount(); i++) {
                if (t.getColumnModel().getColumn(i).getHeaderValue().equals(String.valueOf(cb.getSelectedItem()))) {
                    indiceColumna = i;
                }
            }
        }
        return indiceColumna;
    }

    /**
     * Este método se utiliza para guardar los datos de una tabla en un HashMap.
     * Recibe como parámetros la tabla (JTable) y un JComboBox que representa
     * una referencia para los datos. El método verifica si hay una columna con
     * datos en la tabla utilizando el método "sacarColumnaConDatos". Luego,
     * obtiene la columna de referencia utilizando el método "sacarColumnaRef".
     * Si se encuentra una columna con datos y se obtiene la columna de
     * referencia, se crea un nuevo HashMap llamado "valores". A continuación,
     * recorre todas las filas de la tabla y agrega los datos correspondientes a
     * la columna de referencia y a la columna con datos al HashMap "valores".
     * Si no se encuentra una columna con datos, se establece el valor de
     * "esCorrecto" como falso. Al final, se devuelve el valor de "esCorrecto"
     * para indicar si los datos se guardaron correctamente o no.
     */
    private boolean guardarDatos(JTable t, JComboBox cb) {
        boolean esCorrecto = true;
        int fila = t.getRowCount();
        int columnconDatos = sacarColumnaConDatos(t);
        int columnRef = sacarColumnaRef(t, cb);
        if (columnconDatos != -1) {
            valores = new HashMap<>();
            for (int i = 0; i < fila; i++) {
                valores.put(String.valueOf(t.getValueAt(i, columnRef)), String.valueOf(t.getValueAt(i, columnconDatos)));
            }
        } else {
            esCorrecto = false;
        }
        return esCorrecto;
    }

    /**
     * Este método se utiliza para obtener el índice de la columna de referencia
     * 1 en una tabla, según el valor seleccionado en un JComboBox. Recibe como
     * parámetros la tabla (JTable) en la que se va a buscar la columna de
     * referencia 1 y el JComboBox que contiene los valores de referencia. El
     * método recorre la lista de columnas de la tabla y compara el encabezado
     * de cada columna con el valor seleccionado en el JComboBox. Si encuentra
     * una coincidencia, guarda el índice de la columna. Al finalizar, retorna
     * el índice de la columna de referencia 1.
     */
    private int sacarColumnaRef1(JTable t, JComboBox cb) {
        int indiceColumna = 0;
        if (t.isVisible()) {
            for (int i = 0; i < t.getColumnCount(); i++) {
                if (t.getColumnModel().getColumn(i).getHeaderValue().equals(String.valueOf(cb.getSelectedItem()))) {
                    indiceColumna = i;
                }
            }
        }
        return indiceColumna;
    }

    /**
     * Este método se utiliza para guardar los cambios realizados en la función
     * de deshacer en una tabla. Recibe como parámetro la tabla (JTable) en la
     * cual se realizaron los cambios. El método crea una nueva lista llamada
     * "prueba" para almacenar los datos de la columna seleccionada. Luego,
     * recorre todas las filas de la tabla y obtiene el dato de la columna
     * seleccionada en cada fila. El dato se agrega a la lista "prueba". Por
     * último, se habilitan los botones "btDeshacer" y
     * "btn_siguientemodificado". Esto se realiza para permitir deshacer y
     * avanzar a la siguiente modificación.
     */
    private void guardarCambiosdeDeshacer(JTable t) {
        prueba = new ArrayList<>();
        String dato = "";
        for (int i = 0; i < t.getRowCount(); i++) {
            dato = String.valueOf(t.getValueAt(i, t.getSelectedColumn()));
            prueba.add(dato);
        }
        btDeshacer.setEnabled(true);
        btn_siguientemodificado.setEnabled(true);
    }

    /**
     * Este método se utiliza para deshacer una acción en una tabla. Recibe como
     * parámetro la tabla (JTable) en la cual se desea deshacer la acción. El
     * método recorre todas las filas de la tabla y obtiene el dato
     * correspondiente a través de la lista "prueba". Luego, reemplaza cualquier
     * valor "null" en el dato y lo establece en la columna seleccionada de la
     * fila correspondiente en la tabla. Esto se realiza para deshacer la
     * modificación realizada previamente en la columna seleccionada.
     */
    private void deshacer(JTable t) {
        for (int i = 0; i < t.getRowCount(); i++) {
            String dato = prueba.get(i);
            dato = dato.replaceAll("null", "");
            t.setValueAt(dato, i, t.getSelectedColumn());
        }
    }

    /**
     * Este método se utiliza para rellenar las celdas vacías en una columna
     * específica de una tabla, utilizando un JComboBox como referencia. Recibe
     * como parámetros la tabla (JTable) en la que se van a rellenar las celdas
     * y el JComboBox utilizado como referencia. El método recorre todas las
     * filas de la tabla y verifica si la celda en la columna de referencia 1
     * contiene un valor. Si el RadioButton "API" está seleccionado, se verifica
     * si la celda en la columna seleccionada está vacía. Si cumple ambas
     * condiciones, se obtiene el dato correspondiente al valor de referencia 1
     * desde el mapa de valores. Luego se reemplazan las palabras "null" y
     * "NULL" por una cadena vacía en el dato obtenido. Si el dato no es nulo ni
     * una cadena vacía, se establece como valor de la celda en la columna
     * seleccionada. Se cuenta el número de cambios realizados y se retorna. Si
     * el RadioButton "API" no está seleccionado, se realiza un proceso similar
     * sin verificar si la celda en la columna seleccionada está vacía. Al
     * finalizar, se retorna el número de cambios realizados.
     */
    private int rellenar(JTable t, JComboBox cb) {
        int nCambios = 0;
        int fila = t.getRowCount();
        guardarCambiosdeDeshacer(t);
        for (int i = 0; i < fila; i++) {
            String datoRef1 = String.valueOf(t.getValueAt(i, sacarColumnaRef1(t, cb)));
            if (rbAPI.isSelected()) {
                if (String.valueOf(t.getValueAt(i, t.getSelectedColumn())).equals("")) {
                    if (!datoRef1.equals("")) {
                        try {
                            String dato = valores.get(datoRef1);
                            dato = dato.replaceAll("null", "");
                            dato = dato.replaceAll("NULL", "");
                            if (dato != null && dato.compareTo("") != 0) {
                                t.setValueAt(dato, i, t.getSelectedColumn());
                                if (valores.get(datoRef1) != null && valores.get(datoRef1).compareTo("") != 0) {
                                    nCambios++;
                                }
                            }
                        } catch (Exception e) {
                            t.setValueAt("", i, t.getSelectedColumn());
                        }
                    }
                }
            } else {
                if (!datoRef1.equals("")) {
                    String dato = valores.get(datoRef1);
                    try {
                        if (dato != null && dato.compareTo("") != 0) {
                            t.setValueAt(dato, i, t.getSelectedColumn());
                            if (valores.get(datoRef1) != null && valores.get(datoRef1).compareTo("") != 0) {
                                nCambios++;
                            }
                        }
                    } catch (Exception e) {
                    }
                }
            }
        }
        return nCambios;
    }

    /**
     * Este método se utiliza para sustituir los datos en la tabla "tb_importSF"
     * según ciertas reglas. El método crea un ArrayList de ArrayLists para
     * almacenar los datos de las filas de las tablas "tb_importSF" y
     * "tb_importAPI". Luego, recorre el ArrayList y busca filas con orden de
     * migración "APIGES". Para cada fila con orden de migración "APIGES", busca
     * filas con orden de migración "SIGES" y el mismo Salesforce ID. Si
     * encuentra coincidencias, actualiza el valor en la columna 3 de las filas
     * "SIGES" con el valor de la columna 3 de la fila "APIGES". Luego, elimina
     * la fila "APIGES" del ArrayList. Luego, recorre el ArrayList nuevamente y
     * busca filas "SIGES" con el mismo Salesforce ID. Si encuentra
     * coincidencias, actualiza el valor en la columna 3 de las filas "SIGES"
     * con el valor de la columna 3 de la fila anterior con el mismo Salesforce
     * ID. Finalmente, se actualiza el modelo de la tabla "tb_importSF" con los
     * datos actualizados del ArrayList.
     */
    private void sustituirDC() {
        ArrayList<String> filaporfila;
        ArrayList<ArrayList> todaslasFilas = new ArrayList<>();

        //Meter todos los datos de tabla APIGES al arrayList
        for (int i = 0; i < tb_importSF.getRowCount(); i++) {
            filaporfila = new ArrayList<>();
            for (int j = 0; j < tb_importSF.getColumnCount(); j++) {
                String dato = String.valueOf(tb_importSF.getValueAt(i, j));
                filaporfila.add(dato);
            }
            todaslasFilas.add(filaporfila);
        }
        //Meter todos los datos de tabla SIGES al arrayList
        for (int i = 0; i < tb_importAPI.getRowCount(); i++) {
            filaporfila = new ArrayList<>();
            for (int j = 0; j < tb_importAPI.getColumnCount(); j++) {
                String dato = String.valueOf(tb_importAPI.getValueAt(i, j));
                filaporfila.add(dato);
            }
            todaslasFilas.add(filaporfila);
        }
        //Una vez que esta todo en el ArrayList cogemos un sf id con orden de migracion APIGES
        int cont = 0;
        for (int i = 0; i < todaslasFilas.size(); i++) {
            String ordenmigracion = String.valueOf(todaslasFilas.get(i).get(6));
            if (ordenmigracion.equalsIgnoreCase("APIGES")) {
                String salesforceid1 = String.valueOf(todaslasFilas.get(i).get(7));
                for (int j = i + 1; j < todaslasFilas.size(); j++) {
                    ordenmigracion = String.valueOf(todaslasFilas.get(j).get(6));
                    String outdirect = String.valueOf(todaslasFilas.get(j).get(9));
                    if (ordenmigracion.equalsIgnoreCase("SIGES") && outdirect.equalsIgnoreCase("false")) {
                        String salesforceid2 = String.valueOf(todaslasFilas.get(j).get(7));
                        if (salesforceid1.equals(salesforceid2)) {
                            todaslasFilas.get(j).set(3, todaslasFilas.get(i).get(3));
                            todaslasFilas.remove(i);
                            i--;
                        }
                    } else if (ordenmigracion.equalsIgnoreCase("SIGES") && outdirect.equalsIgnoreCase("true")) {
                        todaslasFilas.get(j).set(3, todaslasFilas.get(i).get(3));
                    }
                }
            }
            cont++;
            System.out.println(cont);
        }
        cont = 0;
        for (int i = 0; i < todaslasFilas.size(); i++) {
            String salesforceid1 = String.valueOf(todaslasFilas.get(i).get(7));
            for (int j = i + 1; j < todaslasFilas.size(); j++) {
                String ordenmigracion = String.valueOf(todaslasFilas.get(j).get(6));
                String salesforceid2 = String.valueOf(todaslasFilas.get(j).get(7));
                if (ordenmigracion.equalsIgnoreCase("SIGES") && salesforceid1.equals(salesforceid2)) {
                    todaslasFilas.get(j).set(3, todaslasFilas.get(i).get(3));
                }
            }
            cont++;
            System.out.println(cont);
        }

        DefaultTableModel model = (DefaultTableModel) tb_importSF.getModel();
        model.setRowCount(0);
        for (int i = 0; i < todaslasFilas.size(); i++) {
            Object[] fila = new Object[tb_importSF.getColumnCount()];
            for (int j = 0; j < todaslasFilas.get(i).size(); j++) {
                fila[j] = todaslasFilas.get(i).get(j);
            }
            model.addRow(fila);
        }
    }

    /**
     * Este método se utiliza para rellenar los JComboBox con los nombres de las
     * columnas de las tablas importadas. El método realiza las siguientes
     * acciones: - Elimina todos los elementos existentes en los JComboBox
     * cb_api, cb_bc y cb_sf. - Crea y ordena listas (cbBCsort, cbAPIsort y
     * cbSFsort) con los nombres de las columnas de las tablas importBC,
     * importAPI y importSF respectivamente. - Agrega los elementos de las
     * listas ordenadas a los JComboBox correspondientes. - cb_bc se llena con
     * los elementos de cbBCsort. - cb_api se llena con los elementos de
     * cbAPIsort. - cb_sf se llena con los elementos de cbSFsort.
     */
    private void rellenarCombos() {
        cb_api.removeAllItems();
        cb_bc.removeAllItems();
        cb_sf.removeAllItems();
        ArrayList<String> cbSFsort;
        cbSFsort = new ArrayList<>();
        ArrayList<String> cbBCsort;
        cbBCsort = new ArrayList<>();
        ArrayList<String> cbAPIsort;
        cbAPIsort = new ArrayList<>();
        for (int i = 0; i < tb_importBC.getColumnCount(); i++) {
            cbBCsort.add(String.valueOf(tb_importBC.getColumnModel().getColumn(i).getHeaderValue()));
            Collections.sort(cbBCsort);
        }
        for (int i = 0; i < cbBCsort.size(); i++) {
            cb_bc.addItem(cbBCsort.get(i));
        }
        for (int i = 0; i < tb_importAPI.getColumnCount(); i++) {
            cbAPIsort.add(String.valueOf(tb_importAPI.getColumnModel().getColumn(i).getHeaderValue()));
            Collections.sort(cbAPIsort);
        }
        for (int i = 0; i < cbAPIsort.size(); i++) {
            cb_api.addItem(cbAPIsort.get(i));
        }
        for (int i = 0; i < tb_importSF.getColumnCount(); i++) {
            cbSFsort.add(String.valueOf(tb_importSF.getColumnModel().getColumn(i).getHeaderValue()));
            Collections.sort(cbSFsort);
        }
        for (int i = 0; i < cbSFsort.size(); i++) {
            cb_sf.addItem(cbSFsort.get(i));
        }

    }

    private void exportarExcel(JTable t) throws IOException {
        JFileChooser chooser = new JFileChooser();
        FileNameExtensionFilter filter = new FileNameExtensionFilter("Archivos de excel", "xls");
        chooser.setFileFilter(filter);
        chooser.setDialogTitle("Seleccione una ruta");
        chooser.setAcceptAllFileFilterUsed(false);
        if (chooser.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {
            String ruta = chooser.getSelectedFile().toString().concat(".xls");
            try {
                File archivoXLS = new File(ruta);
                if (archivoXLS.exists()) {
                    archivoXLS.delete();
                }
                archivoXLS.createNewFile();
                Workbook libro = new HSSFWorkbook();
                FileOutputStream archivo = new FileOutputStream(archivoXLS);
                Sheet hoja = libro.createSheet("SalesForce_EXP");
                hoja.setDisplayGridlines(false);
                for (int f = 0; f < t.getRowCount(); f++) {
                    Row fila = hoja.createRow(f);
                    for (int c = 0; c < t.getColumnCount(); c++) {
                        Cell celda = fila.createCell(c);
                        if (f == 0) {
                            celda.setCellValue(t.getColumnName(c));
                        }
                    }
                }
                int filaInicio = 1;
                for (int f = 0; f < t.getRowCount(); f++) {
                    Row fila = hoja.createRow(filaInicio);
                    filaInicio++;
                    for (int c = 0; c < t.getColumnCount(); c++) {
                        Cell celda = fila.createCell(c);
                        String dato = String.valueOf(t.getValueAt(f, c));
                        dato = dato.replaceAll("null", "");
                        if (t.getValueAt(f, c) instanceof Double) {
                            celda.setCellValue(Double.parseDouble(dato));
                        } else if (t.getValueAt(f, c) instanceof Float) {
                            celda.setCellValue(Float.parseFloat(dato));
                        } else {
                            celda.setCellValue(dato);
                        }
                    }
                }
                libro.write(archivo);
                archivo.close();
                Desktop.getDesktop().open(archivoXLS);
            } catch (Exception e) {
                JOptionPane.showMessageDialog(this, "Ha ocurrido un error. \nIntentelo de nuevo");
            }
        }
    }

    private void resizeColumnWidth(JTable table) {
        TableColumnModel columnModel = table.getColumnModel();
        for (int column = 0; column < table.getColumnCount(); column++) {
            int width = 150;
            for (int row = 0; row < table.getRowCount(); row++) {
                TableCellRenderer renderer = table.getCellRenderer(row, column);
                Component comp = table.prepareRenderer(renderer, row, column);
                width = Math.max(comp.getPreferredSize().width + 1, width);
            }
            if (width > 300) {
                width = 300;
            }
            columnModel.getColumn(column).setPreferredWidth(width);
        }
    }

    private boolean importarExcel(JTable t) {
        isImport = false;
        indiceFila = -1;
        JFileChooser fileChooser = new JFileChooser();

        fileChooser.setDialogTitle("Seleccionar archivo Excel");

        fileChooser.setFileFilter(new FileNameExtensionFilter("Archivos Excel", "xls", "xlsx"));

        int seleccion = fileChooser.showOpenDialog(null);

        if (seleccion == JFileChooser.APPROVE_OPTION) {
            File archivo = fileChooser.getSelectedFile();

            try (FileInputStream archivoExcel = new FileInputStream(archivo)) {

                Workbook workbook = WorkbookFactory.create(archivoExcel);

                Sheet sheet = workbook.getSheetAt(0);

                Iterator<Row> rowIterator = sheet.rowIterator();
                DefaultTableModel model = new DefaultTableModel();
                t.setModel(model);

                int filaAescribir = (Integer.parseInt(JOptionPane.showInputDialog(this, "Introduce a partir de que fila quieres que se escriba el Excel"))) - 1;

                while (rowIterator.hasNext()) {
                    indiceFila++;
                    Row fila = (Row) rowIterator.next();
                    Iterator columnaIterator = fila.cellIterator();
                    Object[] listaColumna = new Object[1000];
                    int indiceColumna = -1;
                    while (columnaIterator.hasNext()) {
                        indiceColumna++;
                        Cell celda = (Cell) columnaIterator.next();
                        if (indiceFila == filaAescribir) {
                            model.addColumn(celda.getStringCellValue());
                        } else {
                            if (celda != null) {
                                if (celda.getCellType() == CellType.NUMERIC) {
                                    listaColumna[indiceColumna] = (int) Math.round(celda.getNumericCellValue());
                                }
                                if (celda.getCellType() == CellType.BOOLEAN) {
                                    listaColumna[indiceColumna] = celda.getBooleanCellValue();
                                }
                                if (celda.getCellType() == CellType.STRING) {
                                    listaColumna[indiceColumna] = celda.getStringCellValue();
                                }
                            }

                        }
                    }
                    if (indiceFila > filaAescribir) {
                        model.addRow(listaColumna);
                    }
                }
                isImport = true;
                resizeColumnWidth(t);
                t.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
                //borrarColumnasinit(t);
                rellenarCombos();

            } catch (Exception ex) {
                JOptionPane.showMessageDialog(this, "Ha ocurrido un error al importar el archivo. \nIntentelo de nuevo");
            }

        } else {
            isImport = false;
        }
        return isImport;

    }

    /**
     * Este método se utiliza para borrar las filas seleccionadas de una JTable.
     * Recibe como parámetro la tabla (JTable) de la cual se desean eliminar las
     * filas. Itera sobre los índices de las filas seleccionadas y las elimina
     * una por una. Después de eliminar una fila, se decrementa el contador 'i'
     * para ajustar el tamaño del arreglo de filas seleccionadas.
     */
    private void borrarFilas(JTable t) {
        for (int i = 0; i < t.getSelectedRows().length; i++) {
            ((javax.swing.table.DefaultTableModel) t.getModel()).removeRow(t.getSelectedRows()[i]);
            i--;
        }
    }

    /**
     * Este método se utiliza para eliminar las columnas vacías de una JTable.
     * Recibe como parámetro la tabla (JTable) de la cual se desean eliminar las
     * columnas. Itera sobre los índices de las columnas de la tabla. Si el
     * encabezado de una columna está vacío, se elimina dicha columna de la
     * tabla.
     */
    private void borrarColumnasinit(JTable t) {
        for (int i = 0; i < t.getColumnCount(); i++) {
            if (t.getColumnModel().getColumn(i).getHeaderValue().equals("")) {
                t.removeColumn(t.getColumnModel().getColumn(i));
            }
        }
    }

    /**
     * Este método se utiliza para borrar las columnas seleccionadas de una
     * JTable. Recibe como parámetro la tabla (JTable) de la cual se desean
     * eliminar las columnas. Itera sobre los índices de las columnas
     * seleccionadas y las elimina una por una. Después de eliminar una columna,
     * se decrementa el contador 'i' para ajustar el tamaño del arreglo de
     * columnas seleccionadas.
     */
    private void borrarColumnas(JTable t) {
        for (int i = 0; i < t.getSelectedColumns().length; i++) {
            t.removeColumn(t.getColumnModel().getColumn(t.getSelectedColumns()[i]));
            i--;
        }
    }

    /**
     * Este método se utiliza para cambiar la vista de las tablas. Recibe como
     * parámetro un número entero "n" que indica la vista deseada. El método
     * actualiza el valor de la variable "vista" y luego utiliza un switch-case
     * para realizar las acciones correspondientes. Dependiendo del valor de
     * "vista", se muestra u oculta la tabla correspondiente, se actualizan los
     * textos y se habilitan/deshabilitan los botones. Además, se realiza un
     * cambio en el texto y acción del botón "jButton1" para cambiar a la vista
     * de la tabla siguiente.
     */
    private void cambiarVista(int n) {
        vista = n;
        vista++;

        if (vista > 2) {
            vista = 0;
        }

        switch (vista) {
            case 0:
                if (tb_importAPI.getRowCount() > 4) {
                    txt_nombretabla.setText("");
                    tb_importAPI.setVisible(true);
                    scroll_API.setVisible(true);
                    tb_importBC.setVisible(false);
                    scroll_BC.setVisible(false);
                    tb_importSF.setVisible(false);
                    scroll_SF.setVisible(false);
                    txt_nombretabla.setText("TABLA APIGES");
                    txt_tablapreview.setText("");
                    btn_mostrar.setEnabled(true);
                    btn_ocultar.setEnabled(true);
                    //headerMouseListener(tb_importAPI);
                } else {
                    txt_nombretabla.setText("TABLA APIGES NO IMPORTADA");
                    tb_importSF.setVisible(false);
                    scroll_SF.setVisible(false);
                    btn_mostrar.setEnabled(false);
                    btn_ocultar.setEnabled(false);
                }
                jButton1.setText("CAMBIAR VISTA A EXCEL BC");
                break;
            case 1:
                if (tb_importBC.getRowCount() > 4) {
                    txt_nombretabla.setText("");
                    tb_importBC.setVisible(true);
                    scroll_BC.setVisible(true);
                    tb_importAPI.setVisible(false);
                    scroll_API.setVisible(false);
                    tb_importSF.setVisible(false);
                    scroll_SF.setVisible(false);
                    txt_nombretabla.setText("TABLA BC");
                    txt_tablapreview.setText("");
                    btn_mostrar.setEnabled(true);
                    btn_ocultar.setEnabled(true);
                    //headerMouseListener(tb_importBC);
                } else {
                    txt_nombretabla.setText("TABLA BC NO IMPORTADA");
                    tb_importAPI.setVisible(false);
                    scroll_API.setVisible(false);
                    btn_mostrar.setEnabled(false);
                    btn_ocultar.setEnabled(false);
                }
                jButton1.setText("CAMBIAR VISTA A EXCEL SF");
                break;
            case 2:
                if (tb_importSF.getRowCount() > 4) {
                    txt_nombretabla.setText("");
                    tb_importSF.setVisible(true);
                    scroll_SF.setVisible(true);
                    tb_importAPI.setVisible(false);
                    scroll_API.setVisible(false);
                    tb_importBC.setVisible(false);
                    scroll_BC.setVisible(false);
                    txt_nombretabla.setText("TABLA SF");
                    txt_tablapreview.setText("");
                    btn_mostrar.setEnabled(true);
                    btn_ocultar.setEnabled(true);
                    //headerMouseListener(tb_importSF);
                } else {
                    txt_nombretabla.setText("TABLA SF NO IMPORTADA");
                    tb_importBC.setVisible(false);
                    scroll_BC.setVisible(false);
                    btn_mostrar.setEnabled(false);
                    btn_ocultar.setEnabled(false);
                }
                jButton1.setText("CAMBIAR VISTA A EXCEL APIGES");
                break;
            default:
                break;
        }
    }

    private void rellenar() {
        if (rbAPI.isSelected()) {
            tb_importAPI.setVisible(true);
            if (guardarDatos(tb_importAPI, cb_api)) {
                tb_importAPI.setVisible(false);
                int cambios = rellenar(tb_importSF, cb_sf);
                JOptionPane.showMessageDialog(rootPane, cambios + " registros modificados.");
            }
        }
        if (rbBC.isSelected()) {
            tb_importBC.setVisible(true);
            if (guardarDatos(tb_importBC, cb_bc)) {
                tb_importBC.setVisible(false);
                int cambios = rellenar(tb_importSF, cb_sf);
                JOptionPane.showMessageDialog(rootPane, cambios + " registros modificados.");
            }
        }
    }

    private void rellenarDC() {
        if (rbAPI.isSelected()) {
            tb_importAPI.setVisible(true);
            sustituirDC();
            tb_importAPI.setVisible(false);
            JOptionPane.showMessageDialog(this, "Se ha realizado con exitos.");

        } else {
            JOptionPane.showMessageDialog(this, "Solo funciona con con la tabla de APIGES.\nPor favor, seleccione APIGES");
        }
    }

    /**
     * Este método se utiliza para iniciar la vista de la interfaz. Establece
     * los valores iniciales de los elementos y componentes de la interfaz. -
     * Establece la variable "vista" en -1 para indicar que no se ha
     * seleccionado ninguna vista. - Deshabilita los botones y elementos que no
     * deben estar activos inicialmente. - Oculta las tablas y los paneles
     * correspondientes. - Limpia y deshabilita los JComboBox de API, BC y SF. -
     * Deshabilita el botón de exportar y establece el texto vacío en el campo
     * de nombre de tabla.
     */
    private void iniciarVista() {
        vista = -1;
        btn_rellenar.setEnabled(false);
        rbAPI.setEnabled(false);
        rbBC.setEnabled(false);
        btn_BorrarColumna.setEnabled(false);
        btn_BorrarFilas.setEnabled(false);
        btDeshacer.setEnabled(false);
        btn_siguientemodificado.setEnabled(false);
        btn_mostrar.setEnabled(false);
        btn_ocultar.setEnabled(false);

        tb_importBC.setVisible(false);
        scroll_BC.setVisible(false);
        tb_importAPI.setVisible(false);
        scroll_API.setVisible(false);
        tb_importSF.setVisible(false);
        scroll_SF.setVisible(false);

        cb_api.removeAllItems();
        cb_api.setEnabled(false);
        cb_sf.removeAllItems();
        cb_sf.setEnabled(false);
        cb_bc.removeAllItems();
        cb_bc.setEnabled(false);

        btn_exportar.setEnabled(false);
        txt_nombretabla.setText("");
    }

    private void descargarPDF() {
        try {
            ClassLoader classLoader = getClass().getClassLoader();
            String filePath = classLoader.getResource("files/nombredelpdf").getFile();
            JFileChooser fileChooser = new JFileChooser();
            fileChooser.setDialogTitle("Seleccionar ruta de descarga");
            fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            int result = fileChooser.showSaveDialog(null);
            if (result == JFileChooser.APPROVE_OPTION) {
                File selectedDir = fileChooser.getSelectedFile();
                FileInputStream fis;
                try {
                    fis = new FileInputStream(filePath);
                } catch (FileNotFoundException e) {
                    JOptionPane.showMessageDialog(this, "Archivo no encontrado");
                    return;
                }
                File outputFile = new File(selectedDir, "insertUsuariosFormat.xlsx");
                FileOutputStream fos;
                try {
                    fos = new FileOutputStream(outputFile);
                } catch (FileNotFoundException e) {
                    JOptionPane.showMessageDialog(this, "No se puede escribir en la ruta seleccionada");
                    return;
                }
                byte[] buffer = new byte[4096];
                int bytesRead;
                try {
                    while ((bytesRead = fis.read(buffer)) != -1) {
                        fos.write(buffer, 0, bytesRead);
                    }
                    JOptionPane.showMessageDialog(this, "Descarga completada");
                } catch (IOException e) {
                    JOptionPane.showMessageDialog(this, "Error al leer/escribir el archivo");
                } finally {
                    try {
                        fis.close();
                        fos.close();
                        Desktop.getDesktop().open(outputFile);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btDeshacer;
    private javax.swing.JButton btn_BorrarColumna;
    private javax.swing.JButton btn_BorrarFilas;
    private javax.swing.JButton btn_buscar;
    private javax.swing.JButton btn_exportar;
    private javax.swing.JButton btn_importApi;
    private javax.swing.JButton btn_importBC;
    private javax.swing.JButton btn_importSF;
    private javax.swing.JButton btn_mostrar;
    private javax.swing.JButton btn_ocultar;
    private javax.swing.JButton btn_rellenar;
    private javax.swing.JButton btn_rellenarDC;
    private javax.swing.JButton btn_siguientemodificado;
    private javax.swing.JButton btn_siguientevacio;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JComboBox<String> cb_api;
    private javax.swing.JComboBox<String> cb_bc;
    private javax.swing.JComboBox<String> cb_sf;
    private javax.swing.JButton descargarPDF;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JRadioButton rbAPI;
    private javax.swing.JRadioButton rbBC;
    private javax.swing.JScrollPane scroll_API;
    private javax.swing.JScrollPane scroll_BC;
    private javax.swing.JScrollPane scroll_SF;
    private javax.swing.JTable tb_importAPI;
    private javax.swing.JTable tb_importBC;
    private javax.swing.JTable tb_importSF;
    private javax.swing.JTextField txt_buscador;
    private javax.swing.JLabel txt_dtTotal;
    private javax.swing.JLabel txt_nombretabla;
    private javax.swing.JLabel txt_tablapreview;
    // End of variables declaration//GEN-END:variables
}
